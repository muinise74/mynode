{"ast":null,"code":"/*!\n * Copyright (c) 2015, Salesforce.com, Inc.\n * All rights reserved.\n *\n * Redistribution and use in source and binary forms, with or without\n * modification, are permitted provided that the following conditions are met:\n *\n * 1. Redistributions of source code must retain the above copyright notice,\n * this list of conditions and the following disclaimer.\n *\n * 2. Redistributions in binary form must reproduce the above copyright notice,\n * this list of conditions and the following disclaimer in the documentation\n * and/or other materials provided with the distribution.\n *\n * 3. Neither the name of Salesforce.com nor the names of its contributors may\n * be used to endorse or promote products derived from this software without\n * specific prior written permission.\n *\n * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\"\n * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE\n * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE\n * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR\n * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF\n * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS\n * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN\n * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)\n * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE\n * POSSIBILITY OF SUCH DAMAGE.\n */\n\"use strict\";\n\nconst {\n  fromCallback\n} = require(\"universalify\");\n\nconst Store = require(\"./store\").Store;\n\nconst permuteDomain = require(\"./permuteDomain\").permuteDomain;\n\nconst pathMatch = require(\"./pathMatch\").pathMatch;\n\nconst {\n  getCustomInspectSymbol,\n  getUtilInspect\n} = require(\"./utilHelper\");\n\nclass MemoryCookieStore extends Store {\n  constructor() {\n    super();\n    this.synchronous = true;\n    this.idx = {};\n    const customInspectSymbol = getCustomInspectSymbol();\n\n    if (customInspectSymbol) {\n      this[customInspectSymbol] = this.inspect;\n    }\n  }\n\n  inspect() {\n    const util = {\n      inspect: getUtilInspect(inspectFallback)\n    };\n    return `{ idx: ${util.inspect(this.idx, false, 2)} }`;\n  }\n\n  findCookie(domain, path, key, cb) {\n    if (!this.idx[domain]) {\n      return cb(null, undefined);\n    }\n\n    if (!this.idx[domain][path]) {\n      return cb(null, undefined);\n    }\n\n    return cb(null, this.idx[domain][path][key] || null);\n  }\n\n  findCookies(domain, path, allowSpecialUseDomain, cb) {\n    const results = [];\n\n    if (typeof allowSpecialUseDomain === \"function\") {\n      cb = allowSpecialUseDomain;\n      allowSpecialUseDomain = true;\n    }\n\n    if (!domain) {\n      return cb(null, []);\n    }\n\n    let pathMatcher;\n\n    if (!path) {\n      // null means \"all paths\"\n      pathMatcher = function matchAll(domainIndex) {\n        for (const curPath in domainIndex) {\n          const pathIndex = domainIndex[curPath];\n\n          for (const key in pathIndex) {\n            results.push(pathIndex[key]);\n          }\n        }\n      };\n    } else {\n      pathMatcher = function matchRFC(domainIndex) {\n        //NOTE: we should use path-match algorithm from S5.1.4 here\n        //(see : https://github.com/ChromiumWebApps/chromium/blob/b3d3b4da8bb94c1b2e061600df106d590fda3620/net/cookies/canonical_cookie.cc#L299)\n        Object.keys(domainIndex).forEach(cookiePath => {\n          if (pathMatch(path, cookiePath)) {\n            const pathIndex = domainIndex[cookiePath];\n\n            for (const key in pathIndex) {\n              results.push(pathIndex[key]);\n            }\n          }\n        });\n      };\n    }\n\n    const domains = permuteDomain(domain, allowSpecialUseDomain) || [domain];\n    const idx = this.idx;\n    domains.forEach(curDomain => {\n      const domainIndex = idx[curDomain];\n\n      if (!domainIndex) {\n        return;\n      }\n\n      pathMatcher(domainIndex);\n    });\n    cb(null, results);\n  }\n\n  putCookie(cookie, cb) {\n    if (!this.idx[cookie.domain]) {\n      this.idx[cookie.domain] = {};\n    }\n\n    if (!this.idx[cookie.domain][cookie.path]) {\n      this.idx[cookie.domain][cookie.path] = {};\n    }\n\n    this.idx[cookie.domain][cookie.path][cookie.key] = cookie;\n    cb(null);\n  }\n\n  updateCookie(oldCookie, newCookie, cb) {\n    // updateCookie() may avoid updating cookies that are identical.  For example,\n    // lastAccessed may not be important to some stores and an equality\n    // comparison could exclude that field.\n    this.putCookie(newCookie, cb);\n  }\n\n  removeCookie(domain, path, key, cb) {\n    if (this.idx[domain] && this.idx[domain][path] && this.idx[domain][path][key]) {\n      delete this.idx[domain][path][key];\n    }\n\n    cb(null);\n  }\n\n  removeCookies(domain, path, cb) {\n    if (this.idx[domain]) {\n      if (path) {\n        delete this.idx[domain][path];\n      } else {\n        delete this.idx[domain];\n      }\n    }\n\n    return cb(null);\n  }\n\n  removeAllCookies(cb) {\n    this.idx = {};\n    return cb(null);\n  }\n\n  getAllCookies(cb) {\n    const cookies = [];\n    const idx = this.idx;\n    const domains = Object.keys(idx);\n    domains.forEach(domain => {\n      const paths = Object.keys(idx[domain]);\n      paths.forEach(path => {\n        const keys = Object.keys(idx[domain][path]);\n        keys.forEach(key => {\n          if (key !== null) {\n            cookies.push(idx[domain][path][key]);\n          }\n        });\n      });\n    }); // Sort by creationIndex so deserializing retains the creation order.\n    // When implementing your own store, this SHOULD retain the order too\n\n    cookies.sort((a, b) => {\n      return (a.creationIndex || 0) - (b.creationIndex || 0);\n    });\n    cb(null, cookies);\n  }\n\n}\n\n[\"findCookie\", \"findCookies\", \"putCookie\", \"updateCookie\", \"removeCookie\", \"removeCookies\", \"removeAllCookies\", \"getAllCookies\"].forEach(name => {\n  MemoryCookieStore.prototype[name] = fromCallback(MemoryCookieStore.prototype[name]);\n});\nexports.MemoryCookieStore = MemoryCookieStore;\n\nfunction inspectFallback(val) {\n  const domains = Object.keys(val);\n\n  if (domains.length === 0) {\n    return \"{}\";\n  }\n\n  let result = \"{\\n\";\n  Object.keys(val).forEach((domain, i) => {\n    result += formatDomain(domain, val[domain]);\n\n    if (i < domains.length - 1) {\n      result += \",\";\n    }\n\n    result += \"\\n\";\n  });\n  result += \"}\";\n  return result;\n}\n\nfunction formatDomain(domainName, domainValue) {\n  const indent = \"  \";\n  let result = `${indent}'${domainName}': {\\n`;\n  Object.keys(domainValue).forEach((path, i, paths) => {\n    result += formatPath(path, domainValue[path]);\n\n    if (i < paths.length - 1) {\n      result += \",\";\n    }\n\n    result += \"\\n\";\n  });\n  result += `${indent}}`;\n  return result;\n}\n\nfunction formatPath(pathName, pathValue) {\n  const indent = \"    \";\n  let result = `${indent}'${pathName}': {\\n`;\n  Object.keys(pathValue).forEach((cookieName, i, cookieNames) => {\n    const cookie = pathValue[cookieName];\n    result += `      ${cookieName}: ${cookie.inspect()}`;\n\n    if (i < cookieNames.length - 1) {\n      result += \",\";\n    }\n\n    result += \"\\n\";\n  });\n  result += `${indent}}`;\n  return result;\n}\n\nexports.inspectFallback = inspectFallback;","map":{"version":3,"names":["fromCallback","require","Store","permuteDomain","pathMatch","getCustomInspectSymbol","getUtilInspect","MemoryCookieStore","constructor","synchronous","idx","customInspectSymbol","inspect","util","inspectFallback","findCookie","domain","path","key","cb","undefined","findCookies","allowSpecialUseDomain","results","pathMatcher","matchAll","domainIndex","curPath","pathIndex","push","matchRFC","Object","keys","forEach","cookiePath","domains","curDomain","putCookie","cookie","updateCookie","oldCookie","newCookie","removeCookie","removeCookies","removeAllCookies","getAllCookies","cookies","paths","sort","a","b","creationIndex","name","prototype","exports","val","length","result","i","formatDomain","domainName","domainValue","indent","formatPath","pathName","pathValue","cookieName","cookieNames"],"sources":["C:/Users/aischool/mynode/client/node_modules/tough-cookie/lib/memstore.js"],"sourcesContent":["/*!\n * Copyright (c) 2015, Salesforce.com, Inc.\n * All rights reserved.\n *\n * Redistribution and use in source and binary forms, with or without\n * modification, are permitted provided that the following conditions are met:\n *\n * 1. Redistributions of source code must retain the above copyright notice,\n * this list of conditions and the following disclaimer.\n *\n * 2. Redistributions in binary form must reproduce the above copyright notice,\n * this list of conditions and the following disclaimer in the documentation\n * and/or other materials provided with the distribution.\n *\n * 3. Neither the name of Salesforce.com nor the names of its contributors may\n * be used to endorse or promote products derived from this software without\n * specific prior written permission.\n *\n * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\"\n * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE\n * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE\n * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR\n * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF\n * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS\n * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN\n * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)\n * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE\n * POSSIBILITY OF SUCH DAMAGE.\n */\n\"use strict\";\nconst { fromCallback } = require(\"universalify\");\nconst Store = require(\"./store\").Store;\nconst permuteDomain = require(\"./permuteDomain\").permuteDomain;\nconst pathMatch = require(\"./pathMatch\").pathMatch;\nconst { getCustomInspectSymbol, getUtilInspect } = require(\"./utilHelper\");\n\nclass MemoryCookieStore extends Store {\n  constructor() {\n    super();\n    this.synchronous = true;\n    this.idx = {};\n    const customInspectSymbol = getCustomInspectSymbol();\n    if (customInspectSymbol) {\n      this[customInspectSymbol] = this.inspect;\n    }\n  }\n\n  inspect() {\n    const util = { inspect: getUtilInspect(inspectFallback) };\n    return `{ idx: ${util.inspect(this.idx, false, 2)} }`;\n  }\n\n  findCookie(domain, path, key, cb) {\n    if (!this.idx[domain]) {\n      return cb(null, undefined);\n    }\n    if (!this.idx[domain][path]) {\n      return cb(null, undefined);\n    }\n    return cb(null, this.idx[domain][path][key] || null);\n  }\n  findCookies(domain, path, allowSpecialUseDomain, cb) {\n    const results = [];\n    if (typeof allowSpecialUseDomain === \"function\") {\n      cb = allowSpecialUseDomain;\n      allowSpecialUseDomain = true;\n    }\n    if (!domain) {\n      return cb(null, []);\n    }\n\n    let pathMatcher;\n    if (!path) {\n      // null means \"all paths\"\n      pathMatcher = function matchAll(domainIndex) {\n        for (const curPath in domainIndex) {\n          const pathIndex = domainIndex[curPath];\n          for (const key in pathIndex) {\n            results.push(pathIndex[key]);\n          }\n        }\n      };\n    } else {\n      pathMatcher = function matchRFC(domainIndex) {\n        //NOTE: we should use path-match algorithm from S5.1.4 here\n        //(see : https://github.com/ChromiumWebApps/chromium/blob/b3d3b4da8bb94c1b2e061600df106d590fda3620/net/cookies/canonical_cookie.cc#L299)\n        Object.keys(domainIndex).forEach(cookiePath => {\n          if (pathMatch(path, cookiePath)) {\n            const pathIndex = domainIndex[cookiePath];\n            for (const key in pathIndex) {\n              results.push(pathIndex[key]);\n            }\n          }\n        });\n      };\n    }\n\n    const domains = permuteDomain(domain, allowSpecialUseDomain) || [domain];\n    const idx = this.idx;\n    domains.forEach(curDomain => {\n      const domainIndex = idx[curDomain];\n      if (!domainIndex) {\n        return;\n      }\n      pathMatcher(domainIndex);\n    });\n\n    cb(null, results);\n  }\n\n  putCookie(cookie, cb) {\n    if (!this.idx[cookie.domain]) {\n      this.idx[cookie.domain] = {};\n    }\n    if (!this.idx[cookie.domain][cookie.path]) {\n      this.idx[cookie.domain][cookie.path] = {};\n    }\n    this.idx[cookie.domain][cookie.path][cookie.key] = cookie;\n    cb(null);\n  }\n  updateCookie(oldCookie, newCookie, cb) {\n    // updateCookie() may avoid updating cookies that are identical.  For example,\n    // lastAccessed may not be important to some stores and an equality\n    // comparison could exclude that field.\n    this.putCookie(newCookie, cb);\n  }\n  removeCookie(domain, path, key, cb) {\n    if (\n      this.idx[domain] &&\n      this.idx[domain][path] &&\n      this.idx[domain][path][key]\n    ) {\n      delete this.idx[domain][path][key];\n    }\n    cb(null);\n  }\n  removeCookies(domain, path, cb) {\n    if (this.idx[domain]) {\n      if (path) {\n        delete this.idx[domain][path];\n      } else {\n        delete this.idx[domain];\n      }\n    }\n    return cb(null);\n  }\n  removeAllCookies(cb) {\n    this.idx = {};\n    return cb(null);\n  }\n  getAllCookies(cb) {\n    const cookies = [];\n    const idx = this.idx;\n\n    const domains = Object.keys(idx);\n    domains.forEach(domain => {\n      const paths = Object.keys(idx[domain]);\n      paths.forEach(path => {\n        const keys = Object.keys(idx[domain][path]);\n        keys.forEach(key => {\n          if (key !== null) {\n            cookies.push(idx[domain][path][key]);\n          }\n        });\n      });\n    });\n\n    // Sort by creationIndex so deserializing retains the creation order.\n    // When implementing your own store, this SHOULD retain the order too\n    cookies.sort((a, b) => {\n      return (a.creationIndex || 0) - (b.creationIndex || 0);\n    });\n\n    cb(null, cookies);\n  }\n}\n\n[\n  \"findCookie\",\n  \"findCookies\",\n  \"putCookie\",\n  \"updateCookie\",\n  \"removeCookie\",\n  \"removeCookies\",\n  \"removeAllCookies\",\n  \"getAllCookies\"\n].forEach(name => {\n  MemoryCookieStore.prototype[name] = fromCallback(\n    MemoryCookieStore.prototype[name]\n  );\n});\n\nexports.MemoryCookieStore = MemoryCookieStore;\n\nfunction inspectFallback(val) {\n  const domains = Object.keys(val);\n  if (domains.length === 0) {\n    return \"{}\";\n  }\n  let result = \"{\\n\";\n  Object.keys(val).forEach((domain, i) => {\n    result += formatDomain(domain, val[domain]);\n    if (i < domains.length - 1) {\n      result += \",\";\n    }\n    result += \"\\n\";\n  });\n  result += \"}\";\n  return result;\n}\n\nfunction formatDomain(domainName, domainValue) {\n  const indent = \"  \";\n  let result = `${indent}'${domainName}': {\\n`;\n  Object.keys(domainValue).forEach((path, i, paths) => {\n    result += formatPath(path, domainValue[path]);\n    if (i < paths.length - 1) {\n      result += \",\";\n    }\n    result += \"\\n\";\n  });\n  result += `${indent}}`;\n  return result;\n}\n\nfunction formatPath(pathName, pathValue) {\n  const indent = \"    \";\n  let result = `${indent}'${pathName}': {\\n`;\n  Object.keys(pathValue).forEach((cookieName, i, cookieNames) => {\n    const cookie = pathValue[cookieName];\n    result += `      ${cookieName}: ${cookie.inspect()}`;\n    if (i < cookieNames.length - 1) {\n      result += \",\";\n    }\n    result += \"\\n\";\n  });\n  result += `${indent}}`;\n  return result;\n}\n\nexports.inspectFallback = inspectFallback;\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}